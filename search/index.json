[{"content":"OverlayFS 原理及应用场景 1. OverlayFS 概述 OverlayFS 是 Linux 内核中的一种联合挂载文件系统，它允许将多个目录层叠在一起，形成一个单一的、统一的文件系统视图。其主要特点是轻量级、高性能，并且不需要额外的存储空间来创建合并后的视图。OverlayFS 从 Linux 3.18 版本开始被正式合并到主线内核中。\n2. OverlayFS 工作原理 2.1 基本结构 OverlayFS 使用了三个主要的概念：\nLower 层：只读层，可以有多个（在较新的内核版本支持） Upper 层：可读写层，只能有一个 Merged 层：合并视图，用户看到并操作的统一视图 当挂载 OverlayFS 时，lower 和 upper 层被合并成一个统一的文件系统视图。\n2.2 文件操作原理 读取操作 当读取文件时，如果文件在 upper 层存在，则直接读取 upper 层的文件；如果不存在，则从 lower 层读取。\n写入操作 当修改一个文件时，OverlayFS 采用写时复制（Copy-On-Write，COW）策略：\n如果文件已在 upper 层存在，则直接修改 如果文件仅在 lower 层存在，则先将其复制到 upper 层，再进行修改 对文件的删除操作也是在 upper 层创建一个特殊的删除标记（whiteout） 2.3 目录合并 目录的处理略有不同：\n列出目录内容时，会合并显示 lower 和 upper 层中的所有文件和子目录 如果同名文件/目录同时存在于两层，则 upper 层的版本会覆盖 lower 层的版本 3. OverlayFS 的关键特性 轻量级：不需要额外的磁盘空间来存储合并视图 高性能：相比其他联合挂载文件系统，有更好的性能表现 透明性：对应用程序完全透明，应用无需感知底层文件系统的复杂性 灵活性：可以根据需要组合不同的文件系统 4. 应用场景 4.1 容器技术 OverlayFS 是 Docker、Podman 等容器技术的主要存储驱动之一：\n基础镜像作为只读的 lower 层 容器运行时的可写层作为 upper 层 多个容器可以共享相同的基础层，节省存储空间和提高启动速度 4.2 实时系统 可以将只读的系统文件作为 lower 层，临时的运行时数据作为 upper 层 系统重启后，上层的更改会丢失，系统恢复到初始状态 4.3 嵌入式系统 在资源受限的嵌入式系统中，可以将只读的固件作为 lower 层 用户数据和配置作为 upper 层存储在可写介质上 4.4 系统升级 将当前系统作为 lower 层，升级内容作为 upper 层 如果升级出现问题，可以轻松回滚到原始状态 ","date":"2025-07-29T09:52:54+08:00","permalink":"https://charles-7777.github.io/hugo-stack/p/overlayfs/","title":"OverlayFS"},{"content":"LXC (Linux 容器) 工作原理详解 LXC (Linux Containers) 是一种操作系统级别的虚拟化技术，它允许在单个 Linux 内核上运行多个隔离的 Linux 系统（容器）。与虚拟机（VM）不同，LXC 不需要模拟硬件，因此它非常轻量级且启动速度快。\nLXC 的核心是利用 Linux 内核的两个关键特性：命名空间 (Namespaces) 和 控制组 (Cgroups)。\nNamespaces：负责隔离，确保一个容器中的进程看不到或影响到另一个容器或宿主机的进程、网络、文件系统等。 Cgroups：负责资源限制和审计，确保每个容器只能使用分配给它的 CPU、内存、I/O 等资源。 本文将重点详细介绍几个关键的命名空间。\n1. PID 命名空间 (PID Namespace) PID (Process ID) 命名空间用于隔离进程 ID。\n原理 隔离进程树：每个 PID 命名空间都有一套独立的进程 ID，从 1 开始。 容器的 init 进程：在一个新的 PID 命名空间中创建的第一个进程会成为该空间的 \u0026ldquo;init\u0026rdquo; 进程，其 PID 为 1。这个进程负责管理容器内的所有其他进程（例如，处理孤儿进程）。如果这个 PID 为 1 的进程终止，内核将终止该命名空间中的所有其他进程。 内外 PID 映射：容器内的进程在容器内部有自己的 PID（例如，PID 1, 2, 3\u0026hellip;），同时在宿主机上也有一个全局唯一的 PID。这意味着从宿主机看，所有容器的进程都是普通的进程，只是被 PID 命名空间隔离开来。 示例 假设我们在宿主机上启动一个 LXC 容器，并在容器内运行 bash。\n容器内视角:\n1 2 3 4 5 6 # 在容器内执行 ps aux USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0.1 0.0 2384 1596 ? Ss 10:00 0:00 /sbin/init root 15 0.0 0.0 4372 3480 pts/0 Ss 10:01 0:00 bash root 25 0.0 0.0 5924 1788 pts/0 R+ 10:02 0:00 ps aux 在这里，init 进程的 PID 是 1，bash 的 PID 是 15。\n宿主机视角:\n1 2 3 4 # 在宿主机执行 ps aux | grep bash # 输出可能像这样 root 12345 0.0 0.0 4372 3480 pts/0 Ss 10:01 0:00 bash 在宿主机上，同一个 bash 进程的 PID 可能是 12345。这种隔离使得容器内的进程管理与宿主机完全分离。\n2. 网络命名空间 (Network Namespace) 网络命名空间为每个容器提供了一个完全独立的网络协议栈。\n原理 独立网络栈：每个网络命名空间都有自己独立的网络设备（如 lo, eth0）、IP 地址、路由表、iptables 防火墙规则、端口号等。一个容器默认无法访问另一个容器或宿主机的网络。 veth 设备对：为了让容器能与外部通信，LXC 通常使用 veth (Virtual Ethernet) 设备对。veth 设备总是成对出现，像一根虚拟网线。数据从一端进入，会从另一端出来。 连接过程: 创建一对 veth 设备，例如 veth_host 和 veth_container。 将 veth_host 留在宿主机的网络命名空间中。 将 veth_container \u0026ldquo;移动\u0026rdquo; 到容器的网络命名空间中，并将其重命名为 eth0。 在宿主机上，通常会创建一个网桥（例如 lxcbr0），并将 veth_host 端连接到这个网桥上。 为容器内的 eth0 分配 IP 地址。 数据流: 容器内 eth0 发出的网络包 -\u0026gt; 通过 veth 对到达宿主机的 veth_host -\u0026gt; 进入宿主机的网桥 lxcbr0 -\u0026gt; 通过宿主机的物理网卡和路由规则与外部网络通信。 这种结构使得每个容器都像一台独立的机器连接到了一个虚拟交换机（网桥）上，实现了网络隔离和互联。\n3. 文件系统命名空间 (Mount Namespace) 文件系统（挂载）命名空间允许每个容器拥有自己独立的文件系统视图，尤其是独立的根目录 (/)。\n原理 隔离挂载点：每个挂载命名空间维护着一个独立的挂载点列表。在一个命名空间中的 mount() 和 umount() 操作不会影响到其他命名空间。 独立的根文件系统 (rootfs)：LXC 利用这个特性为每个容器创建一个独立的根文件系统。容器进程看到的文件系统层次结构与宿主机完全不同。 实现方式: 准备 rootfs：首先，需要为容器准备一个目录，其中包含一个完整的 Linux 系统所需的文件和目录（如 /bin, /etc, /lib, /usr 等）。这通常通过复制一个最小化的系统模板来完成。 pivot_root 系统调用：为了将容器的根目录切换到准备好的 rootfs，LXC 使用 pivot_root 系统调用（或者在某些情况下使用 chroot，但 pivot_root 更强大、更安全）。pivot_root 会将当前进程的根文件系统切换到一个新的挂载点，同时将旧的根文件系统挂载到新根下的一个指定目录中，之后可以将其卸载。 隔离挂载：在容器启动后，它可以在自己的文件系统命名空间内自由地挂载其他设备或文件系统（如 proc, sysfs, tmpfs），而这些挂载对宿主机是不可见的。 通过这种方式，容器内的进程被\u0026quot;囚禁\u0026quot;在其自己的文件系统视图中，无法访问或修改宿主机的文件系统（除非特别配置了绑定挂载 bind mount）。\n其他命名空间 除了以上三个，LXC 还使用了其他命名空间来实现全方位隔离：\nUTS Namespace: 隔离主机名和域名。 IPC Namespace: 隔离进程间通信资源，如 System V IPC 和 POSIX 消息队列。 User Namespace: 隔离用户和组 ID。允许容器内的 root 用户（UID 0）映射为宿主机上的一个非特权用户，极大地提升了安全性。 Cgroup Namespace: 隔离控制组视图。 总结 LXC 通过精巧地组合使用 Linux 内核的 Namespaces 和 Cgroups 特性，为用户提供了一个轻量级、高效且隔离性良好的容器环境。PID、网络和文件系统命名空间是实现这种隔离的基础，它们分别创建了独立的进程树、网络协议栈和文件系统视图，使得容器内的环境看起来就像一个独立的操作系统。\n","date":"2025-07-28T20:00:08+08:00","permalink":"https://charles-7777.github.io/hugo-stack/p/lxc%E8%AF%A6%E8%A7%A3/","title":"LXC详解"},{"content":"对称加密 加密前的原始数据，叫做 原文（ original text ），或者 明文（ plain text ）； 加密后的不规则（ scrambled ）数据，通常叫做 密文（ cipher text ）； 加密所用的密码，通常叫做 密钥（ secret key ）； 对称加密（symmetric encryption）算法最大的特点是，它只有一把密钥，加密和解密过程用的都是同一把密钥，这也符合大众对加密算法的认知，用密码对数据进行加密之后，必须用同一个密码才能将数据解密出来\nAES ，高级加密标准，新一代加密算法标准，速度快，安全级别高； DES ，数据加密标准，速度较快，适用于加密大量数据，但安全性较弱； Blowfish ，使用变长密钥，运行速度很快，非专利算法，没有使用限制； etc 非对称加密 从前有一个黑帮，老大和手下们之间的通信必须加密确保安全。于此同时，老大希望手下发给他的信息，不能被其他手下知晓。若采用对称加密算法，只能给每个手下都分配一个独立的密钥，但老大觉得太麻烦了。该怎么办呢？\n黑帮老大希望他只维护一份密钥，就能达到这样的效果，有办法做到吗？\n可以用非对称加密（asymmetric encryption）\n非对称加密，顾明思议，在加密和解密环节用的密钥是不同的。\n非对称加密算法需要两把不同的密钥，这两把密钥组成一对：\n公钥（ public key ），公钥用来对数据进行 加密 ； 私钥（ private key ），也称为 密钥（ secret key ），用来对数据进行 解密 ； 公钥和私钥总是成对出现，用公钥加密后得到的密文，必须用对应的私钥才能解密； 这套加密机制完美解决了黑帮老大的难题，他只需要生成一对密钥：公钥分发给手下们，他们先用公钥加密信息，再发老大；老大接到密文，就用自己保管的私钥来解密；手下们就算拿到别人发的密文也解不开，因为私钥只有他们老大才有。\n数学原理 公钥和私钥的加密机制看起来非常不可思议，这一切其实来一个神奇的数学原理。\n我们来做一个数字游戏，您随便写下一个整数 m （1\u0026lt;m\u0026lt;7387 ），然后计算m ^3 mod 7387 并把结果告诉我，我就知道您写下的整数 m 是什么\n1 2 3 4 5 6 7 8 9 10 11 # 520 \u0026gt;\u0026gt;\u0026gt; 520 ** 3 % 7387 3842 \u0026gt;\u0026gt;\u0026gt; 3842 ** 4811 % 7387 520 # 1314 \u0026gt;\u0026gt;\u0026gt; 1314 ** 3 % 7387 7382 \u0026gt;\u0026gt;\u0026gt; 7382 ** 4811 % 7387 1314 公钥参数 3 和 7387 ，私钥参数 4811 和 7387 又是怎么生成的呢？ 第一步，随机选择两个质数 p 和 q ： p = 83 q = 89 第二步，计算 p 和 q 的乘积 n ： n = p * q = 7387 第三步，计算 n 的欧拉函数 ，记为 phi ： φ(n) = (p-1) * (q-1) = 7216 第四步，随机选择一个整数 e ，满足1\u0026lt;e\u0026lt;φ(n)，且 e 和φ(n)互质： 选一个质数 e ，使得不能被 e 整除即可。 第五步，计算 e 对φ(n)的模反元素 d ，即找到一个数 d 使得 ed 除以φ(n)的余数为 1 ： ed ≡ 1 mod(φ ( n )) \u0026lt;=\u0026gt; ed = kφ(n) + 1 可以找到一个d :4811\n安全性分析 那么，有无可能在已知n和e的情况下，推导出d？\n1 2 3 ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。 φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。 n=pq。只有将n因数分解，才能算出p和q。 大整数的因数分解，是一件非常困难的事情\n目前，能够被破解的 n 最大位数是 768 位(这里提到的位是指二进制位)，因此有人开始质疑 1024 位密钥的安全性。现在推荐的密钥长度至少要 2048 位，只要长度足够，安全性完全不用担心\n应用场景 加密 公钥加密私钥解密是非对称加密算法最典型的应用场景，特别适用于密钥需要公开的场景，比如 传输层安全协议 TLS ，它为通讯双方提供可靠的加密连接\n如果没有非对称加密算法，TLS 将无法实现。因为对称加密算法要求双方使用同一密钥，加密连接建立之前，只能明文协商密钥。试想浏览器想跟服务器建立安全连接，无论是它选定密钥然后发给服务器，还是服务器选定密钥发给它，只要密钥经过明文传输，加密就失去意义。\n有了非对称加密算法，服务器可以生成一对密钥，私钥自己保管，公钥可以公开。当浏览器请求建立加密连接时，服务器可以将公钥发给浏览器，因为公钥是可以公开的。浏览器将敏感信息用公钥加密后再发给浏览器，只有掌握私钥的服务器才能解密，他人便无法知晓。\n同理，服务器想发敏感信息给客户端，必须由客户端生成的公钥加密。换句话讲，每对密钥解决一个方向的加密问题，通讯双方都需要生成自己的密钥对，负责加密对方发来的数据。\n由于非对称加密算法运算复杂，加密效率不高，通常只是用来加密少量的关键信息，比如协商密钥。回到 TLS 这个例子，其实可以借助非对称加密算法协商密钥，从而直接使用更高效的对称加密算法来加密数据：\n服务器生成公钥和私钥 对； 客户端（浏览器）连接上来后，服务器将公钥发给客户端； 客户端随机生成一个用于对称加密（ AES ）的密钥； 客户端用公钥对生成的密钥进行加密，然后后发给服务器； 服务器收到客户端用公钥加密的密钥后，用自己的私钥解密，至此密钥协商完毕； 由于私钥只有服务器才有，因此第三方无法知晓客户端选定的密钥是啥； 此后通信双方采用对称加密，以该密钥加密数据； 签名 实际上，私钥也可以用来加密数据，加密后的密文只有公钥才能解密。尽管如此，由于公钥是公开的，因此这个机制不能来加密数据，但可以对用来对数据进行签名防伪。\n数字证书(certificate) 信息摘要（ digest ），数据经过哈希算法得到的一串哈希值，代表数据的特征，也称为数据指纹； 摘要算法 ，可以把任意长度的数据，映射成一个定长的字符串（哈希值）； 由于哈希冲突的存在，两份不同的数据，有可能算出相同的摘要值； 摘要算法无法用于数据加密，通常用来校验数据完整性，即 数据防伪 ； 常见的摘要算法有：MD5 、SHA1 、SHA256 、SHA512 。 数字签名（ signature ），摘要由私钥加密后，得到的摘要密文就是数字签名； 签名，由数据发送方生成，这是一个 加密 过程（使用私钥）； 验签，由数据接收方校验，这是一个 解密 过程（使用公钥）； 数字签名只能由私钥生成，因此第三方无法伪造； 在介绍密钥协商时，我们提到服务器先将公钥发给客户端，用公钥保护对称加密密钥，确保通信内容不会被第三方获悉。但如果客户端连接的服务器是假的呢？如果用户对假网站信以为真，输入了账号密码，那么这些敏感信息都会被假网站窃取！\n上节我们也讨论了数字签名，通过它可以实现数据防伪。那么，我们是不是可以利用这项技术来甄别仿冒站点呢\n权威机构生成一对密钥，并提供站点认证审核和数字签名颁发服务； 站点管理员将站点信息，包括域名、运营单位、公钥等信息发给权威机构审核； 权威机构对提交上来的站点信息进行审核，审核通过则用私钥签名后返回给站点管理员； 客户端（浏览器）连接站点服务器，服务器将站点信息以及对应的数字签名发给客户端； 客户端用权威机构提供的公钥来校验数字签名，即可判断站点信息的真伪性； 签名验证通过，客户端从站点信息中取出公钥，与服务端协商密钥，发起加密通信； 由于签名用的私钥只有权威机构掌握，黑客无法伪造数字签名，也就无法架设仿冒站点； 权威机构必须由可信的单位运营； 你可能会觉得，黑客直接盗用站点信息和签名不就可以伪造原站点了嘛？此言差矣！因为公钥属于站点信息\n的一 部分，也会参与签名！客户端和服务端协商密钥时，会使用这个公钥加密密钥。由于黑客不掌握站点私 钥，因此 加密连接无法建立！黑客把公钥替换成自己的吧，签名就不对，肯定会被验出来！\n证书签发实验 CA权威机构 首先，权威机构需要生成一对密钥，cakey.pem 是私钥,\n1 openssl genrsa -out cakey.pem 2048 然后，生成根证书签发申请文件（ csr 文件）：\n1 openssl req -new -key cakey.pem -out ca.csr -subj \u0026#39;/C=CN/ST=Guangdong/L=Guangzhou/O=coding-fans/OU=CA/CN=ca.fasionchan.com\u0026#39; 证书申请文件包含权威机构的信息，包括机构信息(Subject )和公钥(Public Key 部分)可以用下面命令查看：\n1 openssl req -in ca.csr -text -noout 最后，自签根证书（ cer 文件 ）：\n1 openssl x509 -req -days 3650 -sha1 -extensions v3_ca -signkey cakey.pem -in ca.csr -out ca.cer 这一步生成的 cer 文件就是根证书文件，它的主要作用是承载权威机构公钥，以便预装在操作系统或者其他终端。它同样会包含权威机构的信息，公钥，以及对应的签名。\n商业站点（服务端） 首先，站点管理员生成一对密钥\n1 openssl genrsa -out sitekey.pem 2048 然后，生成证书签发申请文件（ csr 文件）：\n1 openssl req -new -key sitekey.pem -out site.csr -subj \u0026#39;/C=CN/ST=Guangdong/L=Guangzhou/O=fasionchan/OU=website/CN=fasionchan.co 证书申请文件包含站点信息和公钥，站点管理员将证书申请文件发给权威机构审核，\n权威机构对申请进行审核，审核通过则用自己的私钥对它进行签名，生成证书(cer 文件):\n1 openssl x509 -req -days 365 -sha1 -extensions v3_req -CA ca.cer -CAkey cakey.pem -CAserial ca.srl -CAcreateserial -in site.csr -out site.cer 证书中保存着包括公钥在内的站点信息，以及权威机构对这些信息的签名。管理员接到权威机构颁发的证书，就可以部署网站了\n浏览器（客户端） 客户端浏览器访问站点，服务端会将其证书发给客户端。客户端先对证书签名进行验证，步骤如下：\n重新对证书中的站点信息计算 摘要值 ； 用公钥对证书中的签名进行解密，得到证书的原始摘要值； 公钥通常由根证书提供，根证书通常预装在系统里； 对比两个摘要值看是否一致； 调用 openssl 工具，一行命令即可完成签名验证\n1 openssl verify -CAfile ca.cer site.cer 总结 数字证书是支撑互联网身份认证的重要技术手段，可以简单理解成经过 CA 权威结构签名认证过的站点信息。由于经过 CA 签名，第三方无法通过伪造手段冒充身份。\n证书由站点信息和 CA 签名组成，站点信息包含站点公钥，公钥用于协商对称加密密钥； 证书由 CA 权威机构审核签发，签名用的是 CA 的私钥； CA 公钥通常以根证书形式预装在系统内，客户端通过它来验证证书签名； 有了数字签名，黑客无法对证书进行篡改，也无法伪造证书，因此无法部署仿冒站点； 若只窃取原站点证书，不做篡改，客户端使用真实站点的公钥，而黑客无法掌握站点私钥，因此加密连接无法建立； 如果篡改原站点证书，换上自己的公钥，但因为没有 CA 私钥无法生成合法签名，也会被识别出来； 转载自数字证书身份认证原理与签发步骤详解 | 小菜学网络\n","date":"2025-07-28T16:36:08+08:00","permalink":"https://charles-7777.github.io/hugo-stack/p/%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3/","title":"证书详解"},{"content":"RESTful API 一、RESTful API概述 1.1 定义 REST（Representational State Transfer）即表现层状态转移，是一种针对网络应用的设计风格，主要用于设计分布式超媒体系统。RESTful API 则是遵循 REST 架构原则的应用程序接口，允许客户端和服务器通过 HTTP 协议进行交互。它采用资源定位的思维模式，将所有的操作都视为对资源的操作，以使系统更加简洁、易于理解和扩展。\n1.2 核心概念 资源（Resource）：RESTful API 中的每一个对象、实体或数据都被抽象为一个资源。例如，用户、文章等都可以作为资源。每个资源都通过一个唯一的 URI（统一资源标识符）标识。比如，/users/123 表示 id 为 123 的用户资源，/posts/456 表示 id 为 456 的文章资源。 URI（统一资源标识符）：用于标识资源的地址，通常使用 URL（统一资源定位符）作为 URI。 HTTP 动作（HTTP Methods）：依赖于 HTTP 协议的常见方法来对资源进行操作，每个 HTTP 方法对应不同的操作： GET：获取服务器上的资源。 POST：在服务器上创建新的资源。 PUT：更新服务器上的资源。 DELETE：删除服务器上的资源。 无状态（Statelessness）：每个请求都应该是独立的，服务器不会在请求之间保存客户端的状态。每次请求都必须包含理解请求所必需的信息。 表现层状态转移（Representational State Transfer）：资源的表现形式可以是 JSON、XML、HTML 等格式，通常 RESTful API 使用 JSON 作为数据交换格式，因为它轻量且易于解析。客户端通过接收资源的表现形式（如 JSON、XML）来感知资源的变化，从而实现状态的“转移”。 二、RESTful API的特点和优势 2.1 特点 资源导向：所有内容都被抽象为资源（如 User、Order、Article 等），每个资源都有一个唯一的标识符（URI）。例如，/users 表示用户资源，/users/1 表示 ID 为 1 的用户。 使用标准协议：基于 HTTP 协议，直接使用其方法（GET、POST 等）来操作资源。 无状态通信：每次请求都包含所有上下文，不依赖服务器保存状态。这使得服务器可以更加容易地进行扩展和负载均衡，因为每个请求都是独立的，不需要考虑之前的请求状态。 统一接口：接口风格统一、易于理解和使用。通过标准的 HTTP 方法（GET、POST、PUT、DELETE 等）和资源标识符（URI）访问资源，简化了系统的整体架构，提升了互操作性。 可缓存：客户端可根据响应头对资源进行缓存，提高性能。利用 HTTP 协议的缓存机制，允许中间件或客户端缓存响应结果，减少不必要的网络请求，从而提升响应速度和减轻服务器负担。 分层架构：客户端无需知道请求最终由谁处理（例如中间层、负载均衡等）。允许通过中间层（如代理服务器、网关）来处理请求，每层只需与相邻层通信，增强了系统的安全性、可扩展性和灵活性。 按需代码（可选）：客户端可以从服务器下载代码或脚本，以扩展其功能，增加了系统的灵活性和可扩展性。 2.2 优势 简洁易懂：使用 HTTP 协议的标准方法和 URI，可以让 API 的设计和使用变得简单。通过 URL 和 HTTP 动词的组合，可以明确地表示对特定资源的操作意图。 灵活性：资源可以有不同的表示形式（JSON、XML 等），同时 HTTP 方法明确区分不同的操作。客户端可以根据自身需求选择合适的数据格式。 扩展性强：通过一致的接口设计，可以很容易地扩展和维护 API。随着应用程序的发展，可以轻松地添加新的资源和操作，而不会影响现有的 API 结构。 无状态性：简化了服务器端的设计，增强了系统的可扩展性。服务器不需要保存客户端的状态信息，使得服务器可以更容易地进行扩展和负载均衡。 跨平台：基于 HTTP 协议，可以被任何支持 HTTP 的客户端调用，适用于各种应用场景，特别是需要跨平台和跨语言交互的系统。 三、RESTful API的设计原则 3.1 基于资源 将网络上的每个实体或概念视为唯一资源是一个关键原则。通过 URL 来表示这些资源，使得资源的定位更加清晰和直观。例如，一个博客文章可以被表示为 /articles/123，其中 “articles” 表示文章资源的集合，“123” 是具体某一篇文章的唯一标识符。这种方式使得开发者和用户都能够轻松地理解和访问特定的资源。以电商平台为例，商品可以表示为 /products，每个具体的商品可以通过 /products/{productId} 来访问，其中 {productId} 是商品的唯一标识。\n3.2 统一接口 资源标识（Resource Identification）：每个资源都应有唯一的 URL。例如，用户资源可以通过 /users/{id} 进行标识，其中 {id} 是用户的具体标识。 资源操作（Resource Manipulation Through Representations）：通过表示（representation）来操作资源，而不是直接操作资源本身。使用标准的 HTTP 方法（GET、POST、PUT、DELETE 等）来操作资源。 自描述消息（Self - descriptive Messages）：响应消息应包含足够的信息以便客户端无需额外文档即可理解。每个请求和响应都包含足够的信息，使得客户端能够理解如何处理它们。 无状态（Stateless）：服务器不保存客户端的上下文信息，每次请求都是独立的。每个请求都必须包含足够的信息，使服务器能够理解和处理该请求，而不依赖于之前的请求。 3.3 使用标准的 HTTP 方法 主要使用 HTTP 方法来定义对资源的操作，常见的 HTTP 方法及其作用如下：\nHTTP 方法 操作 幂等性 安全性 示例 GET 获取资源 ✅ ✅ GET /users 查看所有用户信息；GET /users/id 查看该 id 的用户信息 POST 创建资源 ❌ ❌ POST /users 创建用户，可在 DATA 处带需要的参数 PUT 更新或替换资源 ✅ ❌ PUT /users/id?name='张三'\u0026amp;age=20 修改该 id 的用户信息（name 和 age） PATCH 部分更新资源 ❌ ❌ 对资源进行部分属性的更新 DELETE 删除资源 ✅ ❌ DELETE /users/id 删除该 id 的用户信息 HEAD 获取资源的元数据 ✅ ✅ OPTIONS 获取信息，关于资源的哪些属性是客户端可以改变的 ✅ ✅ 3.4 无状态通信 每个请求必须包含服务器处理该请求所需的所有信息，服务器不依赖之前的请求上下文。这使得服务器可以更加容易地进行扩展和负载均衡，因为每个请求都是独立的，不需要考虑之前的请求状态。例如，当客户端发送多个请求时，服务器不需要记住之前的请求内容，只需要根据当前请求的信息进行处理。\n3.5 返回适当的状态码 API 应返回适当的 HTTP 状态码，准确反映请求结果。常用的状态码如下：\n状态码 含义 说明 200 OK 服务器成功返回用户请求的数据，该操作是幂等的（Idempotent），通用成功。 201 Created 资源已创建，通常用于 POST 请求。 204 No Content 请求成功，但无返回内容，通常用于 DELETE 请求。 400 Bad Request 请求参数有误，服务器无法处理。 401 Unauthorized 认证失败，客户端需要提供身份验证。 403 Forbidden 没有权限访问资源，服务器理解请求，但拒绝执行，通常由于权限问题。 404 Not Found 请求的资源不存在。 500 Internal Server Error 服务器内部错误。 3.6 过滤信息 如果记录数量很多，服务器不可能都将它们返回给用户。API 应该提供参数，过滤返回结果。常见的参数如下：\n?limit=10：指定返回记录的数量。 ?offset=10：指定返回记录的开始位置。 ?page=2\u0026amp;per_page=100：指定第几页，以及每页的记录数。 ?sortby=name\u0026amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。 ?animal_type_id=1：指定筛选条件。 3.7 支持 HATEOAS（超媒体作为应用程序状态引擎） HATEOAS 要求客户端能够通过服务器返回的超链接（URL）导航到相关资源。简而言之，HATEOAS 要求 API 的响应不仅包含资源数据，还应该包含与资源相关的操作链接，帮助客户端更好地理解如何进行下一步操作。例如，获取用户信息时，除了返回用户的详细数据外，API 还可以提供相关操作的链接：\n1 2 3 4 5 6 7 8 9 { \u0026#34;user_id\u0026#34;: 123, \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;links\u0026#34;: { \u0026#34;self\u0026#34;: \u0026#34;/users/123\u0026#34;, \u0026#34;update\u0026#34;: \u0026#34;/users/123/update\u0026#34;, \u0026#34;delete\u0026#34;: \u0026#34;/users/123/delete\u0026#34; } } 3.8 数据格式 返回数据格式通常使用 JSON 或 XML，其中 JSON 因其轻量级和易读性，已成为 RESTful API 事实上的数据交换格式。统一返回 JSON 格式，包含数据、状态码和错误信息，例如：\n1 2 3 4 5 { \u0026#34;status\u0026#34;: 200, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 123, \u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34; }, \u0026#34;error\u0026#34;: null } 3.9 版本控制 当 API 发生变化时，可以通过版本号来管理不同版本的 API，以保持向后兼容性。常见的版本控制策略有：\nURL 路径版本：如 /v1/resource，优点是简单、显式、易缓存；缺点是不够优雅、URL 膨胀。 请求头版本：如 X - API - Version: 1，优点是 URL 干净、松耦合；缺点是难调试、可能被代理移除。 内容协商版本：如 Accept: application/vnd.example.v1+json，优点是 RESTful、标准 HTTP 头；缺点是复杂、客户端支持不一。 查询参数版本：如 /resource?version=1，优点是简单、显式；缺点是不是 RESTful、URL 污染。 四、RESTful API的设计示例 以一个简单的博客平台为例，设计其 RESTful API：\n4.1 资源列表 用户（/users） 文章（/articles） 评论（/comments） 4.2 操作设计 操作 HTTP 方法 URL 说明 获取所有用户 GET /users 返回所有用户的列表 获取特定用户 GET /users/{id} 返回指定 ID 用户的详细信息 创建用户 POST /users 根据请求体中的数据创建新用户 更新用户信息 PUT /users/{id} 更新指定 ID 用户的信息 删除用户 DELETE /users/{id} 删除指定 ID 的用户 获取所有文章 GET /articles 返回所有文章的列表 获取特定文章 GET /articles/{id} 返回指定 ID 文章的详细信息 创建文章 POST /articles 根据请求体中的数据创建新文章 更新文章信息 PUT /articles/{id} 更新指定 ID 文章的信息 删除文章 DELETE /articles/{id} 删除指定 ID 的文章 获取特定文章的评论 GET /articles/{id}/comments 返回指定 ID 文章的所有评论 创建评论 POST /articles/{id}/comments 在指定 ID 文章下创建新评论 删除评论 DELETE /comments/{id} 删除指定 ID 的评论 五、RESTful API的实现 5.1 服务端实现（以 Node.js 为例） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 const express = require(\u0026#39;express\u0026#39;); const app = express(); app.use(express.json()); // 模拟用户数据 const users = [ { id: 1, name: \u0026#39;John Doe\u0026#39;, email: \u0026#39;john@example.com\u0026#39; }, { id: 2, name: \u0026#39;Jane Smith\u0026#39;, email: \u0026#39;jane@example.com\u0026#39; } ]; // 获取所有用户 app.get(\u0026#39;/api/v1/users\u0026#39;, (req, res) =\u0026gt; { res.status(200).json({ status: 200, data: users }); }); // 创建新用户 app.post(\u0026#39;/api/v1/users\u0026#39;, (req, res) =\u0026gt; { const newUser = req.body; users.push(newUser); res.status(201).json({ status: 201, data: newUser }); }); // 获取特定用户 app.get(\u0026#39;/api/v1/users/:id\u0026#39;, (req, res) =\u0026gt; { const userId = parseInt(req.params.id); const user = users.find(u =\u0026gt; u.id === userId); if (user) { res.status(200).json({ status: 200, data: user }); } else { res.status(404).json({ status: 404, error: \u0026#39;User not found\u0026#39; }); } }); // 更新用户信息 app.put(\u0026#39;/api/v1/users/:id\u0026#39;, (req, res) =\u0026gt; { const userId = parseInt(req.params.id); const updatedUser = req.body; const index = users.findIndex(u =\u0026gt; u.id === userId); if (index!== -1) { users[index] = updatedUser; res.status(200).json({ status: 200, data: updatedUser }); } else { res.status(404).json({ status: 404, error: \u0026#39;User not found\u0026#39; }); } }); // 删除用户 app.delete(\u0026#39;/api/v1/users/:id\u0026#39;, (req, res) =\u0026gt; { const userId = parseInt(req.params.id); const index = users.findIndex(u =\u0026gt; u.id === userId); if (index!== -1) { users.splice(index, 1); res.status(204).send(); } else { res.status(404).json({ status: 404, error: \u0026#39;User not found\u0026#39; }); } }); const port = process.env.PORT || 3000; app.listen(port, () =\u0026gt; { console.log(`Server is running on port ${port}`); }); 5.2 客户端调用（以 JavaScript Fetch 为例） 1 2 3 4 5 6 7 8 9 10 11 12 // 获取用户数据 fetch(\u0026#39;https://api.example.com/users/123\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; console.log(data)) .catch(error =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, error)); // 提交新文章 fetch(\u0026#39;https://api.example.com/articles\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content - Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify({ title: \u0026#39;Hello REST\u0026#39;, content: \u0026#39;...\u0026#39; }) }); 六、RESTful API的应用场景 6.1 Web 服务 提供 Web 服务，如社交媒体、电商网站等。前端（如 JavaScript、Angular、React 等）可以通过 RESTful API 与后端服务器进行通信，获取和更新数据。例如，一个电商网站的前端可以使用 RESTful API 从服务器获取商品列表、用户信息等，并将用户的订单信息发送到服务器进行处理。\n6.2 移动应用 移动应用通过 RESTful API 与服务器交互，获取和更新数据，实现用户登录、数据同步等功能。Android 和 iOS 应用可以使用 RESTful API 与服务器交互，提供丰富的用户体验。\n6.3 物联网（IoT） 设备通过 RESTful API 与服务器通信，实现数据采集和控制。物联网设备可以通过 RESTful API 将采集到的数据发送到服务器，同时接收服务器的控制指令。\n6.4 微服务架构 微服务之间通过 RESTful API 进行通信和协作。每个微服务都可以暴露自己的 RESTful API，其他微服务可以通过调用这些 API 来获取所需的数据或执行特定的操作。例如，一个电商系统可能由用户服务、商品服务、订单服务等多个微服务组成，这些微服务之间可以通过 RESTful API 进行数据交互和业务协作。\n6.5 企业级应用集成 企业内部的不同系统之间可以使用 RESTful API 进行集成。例如，企业的客户关系管理系统（CRM）和企业资源规划系统（ERP）可以通过 RESTful API 进行数据交换，实现信息共享和业务流程的协同。\n七、RESTful API与传统 API的对比 比较项 RESTful API 传统 API 风格 接口风格 资源导向，结构清晰 动作导向，接口混乱 动作表示 使用 HTTP 方法表示动作 接口路径中包含动词（如 /getUser） 可读性 高，可直观理解操作含义 低，需要阅读文档才能理解 维护性 易于扩展和维护 扩展性差，接口膨胀 数据传输格式 通常使用 JSON 或 XML，有明确标准 可能使用多种格式，无明确标准 状态与缓存 强调状态无关性，可利用 HTTP 缓存机制 可能依赖服务器端状态，缓存策略不一致 安全性和认证 支持各种安全性措施，如 HTTPS、认证、授权等 可能缺乏统一的安全标准 接口一致性 统一接口，易于使用 接口设计松散，不一致 资源关联性 在响应中提供相关资源的链接，具有自描述性 通常不提供自描述性 综上所述，RESTful API 以其简洁、灵活、可扩展等优点，成为现代 Web 开发中主流的 API 设计风格之一，广泛应用于各种网络应用场景中。在设计和开发 RESTful API 时，遵循其设计原则和最佳实践，能够构建出高效、易用、可维护的 API 系统。\n","date":"2025-06-26T15:22:59+08:00","permalink":"https://charles-7777.github.io/hugo-stack/p/restful-api/","title":"RESTful API"},{"content":"创建public仓库用来存放照片 创建token token将来PicGo操作你的github仓库来上传图片时要用到，在 GitHub 账户下 Setting - Developer setting - Personal access tokens(classic) 下创建一个不过期(no expiration)的 Token，权限需要开启 repo.这个我们在用Github action 来部署博客仓库时已经创建了，用那个就好.token 在创建时只显示一次，要保存好哦！\n配置PicGo github 搜索PicGo 然后安装 图床具体参数配置 仓库名 分支名 对应于之前你创建的GitHub仓库\nToken就是前面创建的Token,被PicGo用来上传照片到长仓库\n路径可以自定义\n自定义域名格式:https://cdn.jsdelivr.net/gh/用户名/仓库名@分支名\nTypora Typora 可搭配PicGo使用\n若PicGo显示unable to verify the first certificate at TLS,无法上传，则可能是你的网络加速工具造成的某些网络加速工具可能会修改网络流量，可能与 SSL证书验证机制发生冲突。这可能导致 SSL 证书验证失败，因为服务器的证书无法正常验证，从而出现类似 \u0026ldquo;unable to verify the first certificate\u0026rdquo; 的错误。例如我之前用Watt Toolkit就出现了：\n如果Typora显示failed to fetch ；检查PicGo server 设置的监听地址是否一致（点击Typora图片设置中的验证图片上传）\njsDelivr jsDelivr是一个免费、开源的加速CDN公共服务,托管了许多大大小小的项目,可加速访问托管的项目目录或图片资源。 他支持提供npm、Github、WordPress上资源cdn服务。\nCDN (全称 Content Delivery Network)，即内容分发网络。\nCDN构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。\nCDN 的关键技术主要有内容存储和分发技术，简单来讲，CDN就是根据用户位置分配最近的资源，于是，用户在上网的时候不用直接访问源站，而是访问离他“最近的”一个 CDN 节点(也叫做“边缘节点”、edge node)，其实就是缓存了源站内容的代理服务器\n","date":"2025-06-12T19:33:46+08:00","permalink":"https://charles-7777.github.io/hugo-stack/p/github--picgo-%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/","title":"Github + PicGo 搭建图床"},{"content":" 创建仓库 首先在github创建两个仓库，一个用于存储hugo new site创建的workspace，这个设置为private私密；另一个仓库用来存储hugo -D生成的网页文件 ，设置为公开:\n本地获取ssh密钥 终端输入命令：\n1 2 git config --global user.email \u0026#34;you@example.com\u0026#34; #you@example.com替换为你的邮箱 git config --global user.name \u0026#34;Your Name\u0026#34; #Your Name替换为你的名字并回车 生成ssh key,在git bash中输入以下命令:\nssh-keygen -t rsa -C \u0026quot;your_email@example.com\u0026quot; 生成的密钥将存储在C:\\uers\\username\\.ssh\\路径下 打开公钥文件 id_rsa.pub， 复制所有内容，在GitHub上打开Setting -\u0026gt; SSH and GPG keys -\u0026gt; add SSH key，将复制的内容粘贴在里边，保存。\n若配置完后，还是显示无法连接到github,可能是你的Windows电脑的username 是中文导致的bug 或者尝试在.ssh 下创建一个config 文件\n1 2 3 4 5 6 Host github.com HostName ssh.github.com # **这是最重要的部分** User git Port 443 PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa 创建github token 在 GitHub 账户下 Setting - Developer setting - Personal access tokens(classic) 下创建一个不过期(no expiration)的 Token，权限需要开启 repo 与 workflow。\n（注意：token只会显示一次，请及时保存） 私密源仓库设置token 在博客源仓库的 Settings-\u0026gt;Secrets-\u0026gt;Actions 中添加 PERSONAL_TOKEN 环境变量为刚才的 Token,\n这样 GitHub Action 就可以获取到Token 了。 本地首次创建博客 1 2 3 hugo new site hugo-stack-blog-dev git init git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack git submodule主要是将自己的改动，与引用的stack主题仓库分开。hugo-theme-stack 下的目录结构基本与站点源目录结构一致 hugo 生成网站时优先寻找站点源目录下的，找不到，才会去stack主题对应目录下寻找\n接下来将 exampleSite样例数据中的 Content 和 hugo.yaml 复制到主文件夹中，并删掉hugo.toml\n可以hugo server -D看一下初始网站长啥样\n创建一篇新文章(在主目录下)\n1 hugo new post/blog1/index.zh-cn.md 初始化博客源仓库，提交到github\n1 2 3 4 5 git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin git@github.com:charles-7777/hugo-stack-blog-dev.git git push -u origin main 创建workflows发布文件 在本地博客主目录下创建 .github/workflows目录，然后创建xxxx.yaml文件。我的 GitHub Action 配置为，自动发布示例配置如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 name: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: submodules: recursive fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;0.147.7\u0026#34; extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.TOKEN }} EXTERNAL_REPOSITORY: charles-7777/hugo-stack PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy 提交github action的改动后，每次push hugo-stack-blog-dev ,就会把基于这个厂库 hugo -D 生成的文件 自动push 到仓库 hugo-stack\nGitHub Pages 前往hugo-stack 仓库的settings--\u0026gt;Pages去添加deploy GitHub Pages 在别的电脑拉取源仓库修改 1 2 3 git clone git@github.com:charles-7777/hugo-stack-blog-dev.git git submodule init git submodule update 参考链接\nhttps://letere-gzj.github.io/hugo-stack/tags/hugo/\n参考博主letere-gzj的视频 markdown中的图片也可以不用本地的图片，可以使用网络url，可以自己创建一个图床，方便管理。 github图床\n","date":"2025-06-09T00:00:00Z","image":"https://cdn.jsdelivr.net/gh/charles-7777/ImageBed@main/blog/hugo.png","permalink":"https://charles-7777.github.io/hugo-stack/p/hugo-stack-blog-%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/","title":"hugo stack blog 搭建记录"}]